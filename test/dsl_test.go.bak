package test

import (
	"bufio"
	"fmt"
	"io"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

type TokenType int

const (
	NUMBER TokenType = iota
	PLUS
	MINUS
	TIMES
	DIVIDE
	UMINUS
	EOF
)

type Token struct {
	Type  TokenType
	Value string
}

type Lexer struct {
	reader *bufio.Reader
}

func NewLexer(r io.Reader) *Lexer {
	return &Lexer{reader: bufio.NewReader(r)}
}

func (l *Lexer) NextToken() Token {
	var ch byte
	var err error
	for {
		ch, err = l.reader.ReadByte()
		if err!= nil {
			return Token{Type: EOF, Value: ""}
		}
		if ch ==' ' || ch == '\t' || ch == '\n' || ch == '\r' {
			continue
		}
		break
	}
	switch ch {
	case '+':
		return Token{Type: PLUS, Value: "+"}
	case '-':
		return Token{Type: MINUS, Value: "-"}
	case '*':
		return Token{Type: TIMES, Value: "*"}
	case '/':
		return Token{Type: DIVIDE, Value: "/"}
	case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
		buf := strings.Builder{}
		buf.WriteByte(ch)
		for {
			ch, err = l.reader.ReadByte()
			if err!= nil {
				break
			}
			if ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch ==' ' || ch == '\t' || ch == '\n' || ch == '\r' {
				l.reader.UnreadByte()
				break
			}
			buf.WriteByte(ch)
		}
		return Token{Type: NUMBER, Value: buf.String()}
	
	}
	return Token{Type: EOF, Value: ""}
	
}


func TestLexer(t *testing.T) {
	assert := assert.New(t)
	lexer := NewLexer(strings.NewReader("123 + 456"))
	token := lexer.NextToken()
	fmt.Println(fmt.Sprintf("%+v", token))
	assert.Equal(NUMBER, token.Type)
	assert.Equal("123", token.Value)
	token = lexer.NextToken()
	assert.Equal(PLUS, token.Type)
	token = lexer.NextToken()
	assert.Equal(NUMBER, token.Type)
	assert.Equal("456", token.Value)
	token = lexer.NextToken()
	assert.Equal(EOF, token.Type)
}